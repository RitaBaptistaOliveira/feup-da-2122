<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Agência de Viagens: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Agência de Viagens
   </div>
   <div id="projectbrief">Desenho de Algoritmos - DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d6805c36afcda590183c57a12728c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a517d6805c36afcda590183c57a12728c">setSize</a> (int <a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a>)</td></tr>
<tr class="separator:a517d6805c36afcda590183c57a12728c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e61c471e90d86011b827fa986fc2581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0e61c471e90d86011b827fa986fc2581">addEdge</a> (int src, int dest, int capacity=1, int duration=0)</td></tr>
<tr class="separator:a0e61c471e90d86011b827fa986fc2581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd25fb6572f6a592e7fb491d6462f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a17dd25fb6572f6a592e7fb491d6462f6">scenario1_1</a> (int src, int target)</td></tr>
<tr class="separator:a17dd25fb6572f6a592e7fb491d6462f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea474417440a612ae4edcfeaffbaf3ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aea474417440a612ae4edcfeaffbaf3ea">scenario1_2</a> (int src, int target)</td></tr>
<tr class="separator:aea474417440a612ae4edcfeaffbaf3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedd932d5ff46a4ec13e6da67dfb9e5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abedd932d5ff46a4ec13e6da67dfb9e5e">widestPath</a> (int src, int target)</td></tr>
<tr class="separator:abedd932d5ff46a4ec13e6da67dfb9e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e828a6d59c61309e8fe1d05e1a0ee48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8e828a6d59c61309e8fe1d05e1a0ee48">bfs</a> (int src)</td></tr>
<tr class="separator:a8e828a6d59c61309e8fe1d05e1a0ee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d568d454c82d54ad8b8ef13334a068"><td class="memItemLeft" align="right" valign="top">list&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a40d568d454c82d54ad8b8ef13334a068">bfs_path</a> (int src, int target)</td></tr>
<tr class="separator:a40d568d454c82d54ad8b8ef13334a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a2c5e0ddae0ff2a0c7259186896815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a71a2c5e0ddae0ff2a0c7259186896815">computePath</a> (int target, list&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:a71a2c5e0ddae0ff2a0c7259186896815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab45c99e1b9583070517f47154a835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afbab45c99e1b9583070517f47154a835">scenario2_1_2</a> (int src, int target, int size)</td></tr>
<tr class="separator:afbab45c99e1b9583070517f47154a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29aa0a85ed4bb984af3776a593fa4b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac29aa0a85ed4bb984af3776a593fa4b0">scenario2_3</a> (int src, int target)</td></tr>
<tr class="separator:ac29aa0a85ed4bb984af3776a593fa4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22620f55768792f01a2a019b0d9298c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a22620f55768792f01a2a019b0d9298c3">bfsFF</a> (int src, int target)</td></tr>
<tr class="separator:a22620f55768792f01a2a019b0d9298c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00feb578bf8f25a2d857a5dd49471abb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a00feb578bf8f25a2d857a5dd49471abb">edmondsKarp</a> (int src, int target, vector&lt; list&lt; int &gt; &gt; &amp;paths)</td></tr>
<tr class="separator:a00feb578bf8f25a2d857a5dd49471abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f18033ff39568e0f965a5b7081b71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab93f18033ff39568e0f965a5b7081b71">edmondsKarpAlt</a> (int src, int target, int groupSize, vector&lt; list&lt; int &gt; &gt; &amp;paths, bool &amp;maxReached, int &amp;maxFlow)</td></tr>
<tr class="separator:ab93f18033ff39568e0f965a5b7081b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda49286a11ba2f572fc7269de5e286c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abda49286a11ba2f572fc7269de5e286c">EK</a> (int src, int target, vector&lt; list&lt; int &gt; &gt; &amp;paths, int &amp;maxFlow, int &amp;pathFlow)</td></tr>
<tr class="separator:abda49286a11ba2f572fc7269de5e286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac05db53839e72af76cdb2bafe88b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5ac05db53839e72af76cdb2bafe88b77">printGraph</a> ()</td></tr>
<tr class="separator:a5ac05db53839e72af76cdb2bafe88b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9498dbb30de02a9a08ecbb55c61d84c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac9498dbb30de02a9a08ecbb55c61d84c">updateFlow</a> (int src, int target, int flow)</td></tr>
<tr class="separator:ac9498dbb30de02a9a08ecbb55c61d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfee6be8acfca13b1fa694d63b15f54"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aabfee6be8acfca13b1fa694d63b15f54">earliestStart</a> (bool print)</td></tr>
<tr class="separator:aabfee6be8acfca13b1fa694d63b15f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40c862314b2b0e830137629cf3a63fe"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac40c862314b2b0e830137629cf3a63fe">latestFinish</a> ()</td></tr>
<tr class="separator:ac40c862314b2b0e830137629cf3a63fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534dea620dd1e5657bd92491d1b840d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a534dea620dd1e5657bd92491d1b840d6">maxWaitingTime</a> ()</td></tr>
<tr class="separator:a534dea620dd1e5657bd92491d1b840d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95336877b2f6a97448bd23aa78a3d9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a95336877b2f6a97448bd23aa78a3d9fb">transposeGraph</a> ()</td></tr>
<tr class="separator:a95336877b2f6a97448bd23aa78a3d9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a61e3d82a0322fdc5039d3bdad4185a5e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a61e3d82a0322fdc5039d3bdad4185a5e">displayPath</a> (list&lt; int &gt; &amp;path, int cap)</td></tr>
<tr class="separator:a61e3d82a0322fdc5039d3bdad4185a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad786542dca27cbeb7be026b9bcad081d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad786542dca27cbeb7be026b9bcad081d">displayPaths</a> (vector&lt; list&lt; int &gt; &gt; &amp;paths, int flow)</td></tr>
<tr class="separator:ad786542dca27cbeb7be026b9bcad081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a81a76a428e630453ef019a15b9092967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a81a76a428e630453ef019a15b9092967">n</a></td></tr>
<tr class="separator:a81a76a428e630453ef019a15b9092967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a></td></tr>
<tr class="separator:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5068ef46316cc9eccbeeaf6d2987f60d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5068ef46316cc9eccbeeaf6d2987f60d">minDuration</a></td></tr>
<tr class="separator:a5068ef46316cc9eccbeeaf6d2987f60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor of the <a class="el" href="class_graph.html">Graph</a> class. Initializes a new instance of the <a class="el" href="class_graph.html">Graph</a> class using default values </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a517d6805c36afcda590183c57a12728c" name="a517d6805c36afcda590183c57a12728c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517d6805c36afcda590183c57a12728c">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::setSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the size of the graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Size of the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e61c471e90d86011b827fa986fc2581" name="a0e61c471e90d86011b827fa986fc2581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e61c471e90d86011b827fa986fc2581">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds an edge to the list of edge of the src node The edge represents the trip of a certain duration the bus with a certain capacity makes from src to dest </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node where the edge is going to be added </td></tr>
    <tr><td class="paramname">dest</td><td>The destination of the edge </td></tr>
    <tr><td class="paramname">capacity</td><td>The capacity of the edge </td></tr>
    <tr><td class="paramname">duration</td><td>The duration of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17dd25fb6572f6a592e7fb491d6462f6" name="a17dd25fb6572f6a592e7fb491d6462f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd25fb6572f6a592e7fb491d6462f6">&#9670;&nbsp;</a></span>scenario1_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::scenario1_1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scenario 1.1 Uses the Widest Path algorithm to return the maximum capacity of the network Time complexity: Same as the Widest Path algorithm: O(log(V) * E), where V is the number of nodes and E is the number of edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the path from src to target is not possible or 0 otherwise </dd></dl>

</div>
</div>
<a id="aea474417440a612ae4edcfeaffbaf3ea" name="aea474417440a612ae4edcfeaffbaf3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea474417440a612ae4edcfeaffbaf3ea">&#9670;&nbsp;</a></span>scenario1_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::scenario1_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scenario 1.2 Maximizes the group size (the capacity) and/or minimizes the amount of bus transfers Chooses if one option is better than the other and displays it, or displays both options if the situation is pareto optimal Uses the BFS to minimize the amount of bus transfers and the Widest Path algorithm to maximize the group size Time Complexity: Same as the Widest Path algorithm: O(log(V) * E), where V is the number of nodes and E is the number of edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the path from src to target is not possible or 0 otherwise </dd></dl>

</div>
</div>
<a id="abedd932d5ff46a4ec13e6da67dfb9e5e" name="abedd932d5ff46a4ec13e6da67dfb9e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedd932d5ff46a4ec13e6da67dfb9e5e">&#9670;&nbsp;</a></span>widestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::widestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Widest Path algorithm. Variant of the Dijkstra algorithm Maximizes the weight (i.e. the capacity) of the minimun-weight edge in the path. Time complexity: O(log(V) * E), where V is the number of nodes and E is the number of edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e828a6d59c61309e8fe1d05e1a0ee48" name="a8e828a6d59c61309e8fe1d05e1a0ee48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e828a6d59c61309e8fe1d05e1a0ee48">&#9670;&nbsp;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Breadth First Search. Computes the path with the least amount of nodes from the given source node Time Complexity: O(V + E), where V is the number of nodes and E is the number of edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40d568d454c82d54ad8b8ef13334a068" name="a40d568d454c82d54ad8b8ef13334a068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d568d454c82d54ad8b8ef13334a068">&#9670;&nbsp;</a></span>bfs_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; int &gt; Graph::bfs_path </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calls the BFS algorithm and composes the path Time Complexity: Same as the BFS: O(V + E), where V is the number of nodes and E is the number of edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an empty list if a path from src to target doesn't exist or the path from src to target otherwise </dd></dl>

</div>
</div>
<a id="a71a2c5e0ddae0ff2a0c7259186896815" name="a71a2c5e0ddae0ff2a0c7259186896815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a2c5e0ddae0ff2a0c7259186896815">&#9670;&nbsp;</a></span>computePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::computePath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Composes the path for scenarios 1.1 and 2.2 Time Complexity: O(n) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">path</td><td>List with nodes forming a path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e3d82a0322fdc5039d3bdad4185a5e" name="a61e3d82a0322fdc5039d3bdad4185a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e3d82a0322fdc5039d3bdad4185a5e">&#9670;&nbsp;</a></span>displayPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::displayPath </td>
          <td>(</td>
          <td class="paramtype">list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Displays the path and its capacity Time Complexity: O(n) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>List with the numbers of the nodes that form the path </td></tr>
    <tr><td class="paramname">cap</td><td>Capacity of the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbab45c99e1b9583070517f47154a835" name="afbab45c99e1b9583070517f47154a835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab45c99e1b9583070517f47154a835">&#9670;&nbsp;</a></span>scenario2_1_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::scenario2_1_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scenario 2.1 and 2.2 Determines the paths a group of a given size that can separate itself can take from a origin to a destination Allows the user to increment the group size by a given number of people, if they desire </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">size</td><td>Initial size of the group (specified by the user) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29aa0a85ed4bb984af3776a593fa4b0" name="ac29aa0a85ed4bb984af3776a593fa4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29aa0a85ed4bb984af3776a593fa4b0">&#9670;&nbsp;</a></span>scenario2_3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::scenario2_3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scenario 2.3 Determines the maximum group dimension (i.e. the maximum flow) using the Edmonds-Karp algorithm and their multiple paths </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22620f55768792f01a2a019b0d9298c3" name="a22620f55768792f01a2a019b0d9298c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22620f55768792f01a2a019b0d9298c3">&#9670;&nbsp;</a></span>bfsFF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::bfsFF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Breadth First Search (for the Ford Fulkerson Method) Uses the BFS to compute the path with the least amount of nodes from the given source node Unlike a standard BFS, it has into account the flow and the capacity of each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no paths to the target node, or false otherwise </dd></dl>

</div>
</div>
<a id="a00feb578bf8f25a2d857a5dd49471abb" name="a00feb578bf8f25a2d857a5dd49471abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00feb578bf8f25a2d857a5dd49471abb">&#9670;&nbsp;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Ford-Fulkerson Method using the Edmonds-Karp algorithm Uses the Edmonds-Karp algorithm to calculate maximum flow between the source and the target node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">paths</td><td>Vector with multiple list of the different path taken by the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow of the graph </dd></dl>

</div>
</div>
<a id="ab93f18033ff39568e0f965a5b7081b71" name="ab93f18033ff39568e0f965a5b7081b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93f18033ff39568e0f965a5b7081b71">&#9670;&nbsp;</a></span>edmondsKarpAlt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::edmondsKarpAlt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>maxReached</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Ford-Fulkerson Method using the Edmonds-Karp algorithm Uses the Edmonds-Karp Algorithm in a way that allows the network to be filled up tp a certain group size(i.e. flow) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">groupSize</td><td>Group size chosen by the user </td></tr>
    <tr><td class="paramname">paths</td><td>Vector with multiple list of the different path taken by the group </td></tr>
    <tr><td class="paramname">maxReached</td><td>Boolean used to check if the maximum flow has or hasn't been reached </td></tr>
    <tr><td class="paramname">maxFlow</td><td>Maximum Flow in the network at a given moment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flow of the graph. In this case, either the group size or the maximum flow </dd></dl>

</div>
</div>
<a id="abda49286a11ba2f572fc7269de5e286c" name="abda49286a11ba2f572fc7269de5e286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda49286a11ba2f572fc7269de5e286c">&#9670;&nbsp;</a></span>EK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::EK </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxFlow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>pathFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Auxiliary function for the Edmonds-Karp algorithm Composes the path and calculates the path flow </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">paths</td><td>Vector with multiple list of the different path taken by the group </td></tr>
    <tr><td class="paramname">maxFlow</td><td>Maximum Flow in the network at a given moment </td></tr>
    <tr><td class="paramname">pathFlow</td><td>Flow of a specific path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac05db53839e72af76cdb2bafe88b77" name="a5ac05db53839e72af76cdb2bafe88b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac05db53839e72af76cdb2bafe88b77">&#9670;&nbsp;</a></span>printGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints all the edges of the graph along with their capacity and flow </p>

</div>
</div>
<a id="ad786542dca27cbeb7be026b9bcad081d" name="ad786542dca27cbeb7be026b9bcad081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad786542dca27cbeb7be026b9bcad081d">&#9670;&nbsp;</a></span>displayPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::displayPaths </td>
          <td>(</td>
          <td class="paramtype">vector&lt; list&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Displays the multiple paths taken by a group that can be separated in a network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>Vector with multiple list of the different path taken by the group </td></tr>
    <tr><td class="paramname">flow</td><td>Flow of the network </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9498dbb30de02a9a08ecbb55c61d84c" name="ac9498dbb30de02a9a08ecbb55c61d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9498dbb30de02a9a08ecbb55c61d84c">&#9670;&nbsp;</a></span>updateFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::updateFlow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Updates the flow of each edge of the graph along a path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Number of the origin/source node </td></tr>
    <tr><td class="paramname">target</td><td>Number of the destination/target node </td></tr>
    <tr><td class="paramname">flow</td><td>Flow to be added to each edge of the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabfee6be8acfca13b1fa694d63b15f54" name="aabfee6be8acfca13b1fa694d63b15f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfee6be8acfca13b1fa694d63b15f54">&#9670;&nbsp;</a></span>earliestStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::earliestStart </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the earliest start of each node of the graph </p><dl class="section return"><dt>Returns</dt><dd>a vector with all the earliest finish values </dd></dl>

</div>
</div>
<a id="ac40c862314b2b0e830137629cf3a63fe" name="ac40c862314b2b0e830137629cf3a63fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40c862314b2b0e830137629cf3a63fe">&#9670;&nbsp;</a></span>latestFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::latestFinish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the earliest start of each node of the graph </p><dl class="section return"><dt>Returns</dt><dd>a vector with all the latest finish values </dd></dl>

</div>
</div>
<a id="a534dea620dd1e5657bd92491d1b840d6" name="a534dea620dd1e5657bd92491d1b840d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534dea620dd1e5657bd92491d1b840d6">&#9670;&nbsp;</a></span>maxWaitingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maxWaitingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the total slack of each node of the graph </p>

</div>
</div>
<a id="a95336877b2f6a97448bd23aa78a3d9fb" name="a95336877b2f6a97448bd23aa78a3d9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95336877b2f6a97448bd23aa78a3d9fb">&#9670;&nbsp;</a></span>transposeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::transposeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Transposes a graph and returns an instance of the new graph </p><dl class="section return"><dt>Returns</dt><dd>graph transposed </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a81a76a428e630453ef019a15b9092967" name="a81a76a428e630453ef019a15b9092967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a76a428e630453ef019a15b9092967">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="class_graph.html">Graph</a> size (number of stops) </p>

</div>
</div>
<a id="a71b5e16eb9e0670fea3ecee3526abb41" name="a71b5e16eb9e0670fea3ecee3526abb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b5e16eb9e0670fea3ecee3526abb41">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_graph_1_1_node.html">Node</a>&gt; Graph::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The list of nodes being represented </p>

</div>
</div>
<a id="a5068ef46316cc9eccbeeaf6d2987f60d" name="a5068ef46316cc9eccbeeaf6d2987f60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5068ef46316cc9eccbeeaf6d2987f60d">&#9670;&nbsp;</a></span>minDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::minDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Minimum duration of travel </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/rita_/OneDrive/Documentos/DA/feup-DA-proj2/src/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/rita_/OneDrive/Documentos/DA/feup-DA-proj2/src/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
